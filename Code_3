% -------------------------------------------------------------------------
% Course: Hydrology for Engineers
% Assignment 1
% Part 3: Construction of depth-duration-frequency (DDF) curves 
% -------------------------------------------------------------------------

clear variables %clear the workspace variables
close all %close all figures
clc %clear the command window

% -------------------------------------------------------------------------
% # 1: Calibrate the DDF curve parameters
% useful functions: linspace
% -------------------------------------------------------------------------

% import the data from previous part
load assignment1_output_part2.mat 

c_values = linspace(0,100,5);
f_values = linspace(-1,1,5);
e_values = linspace(0,1,5);

return_periods = {'T10', 'T40', 'T100'};
errors = [25,60,120];

% Initialize arrays to store parameter values and errors
calibrated_params = zeros(length(return_periods), 4); 

for return_periods_index = 1:length(return_periods) 
    T = return_periods{return_periods_index};
    gumbel_data = H_Gum(return_periods_index, :); %avoir le gumbel pour chaque temps de retour
    max_errors = errors(return_periods_index); % meme dimension donc idx cbn
    
    %initialiser encoooore
    best_error = inf;
    best_params = zeros(1,3);
    
    % itération sur chaque valeur
    for c = c_values
        for f = f_values
            for e = e_values
                error = sum_squared_differences(durations, gumbel_data, c, e, f);
                
                if error < best_error 
                    best_error = error;
                    best_params = [c,e,f];  % stocker les nvx best params 
                end 
            end 
        end
    end
    
    % Store best parameters and error
    calibrated_params(return_periods_index, :) = [best_params, best_error];

    % chatgipitou

    % Output the best parameters and error for the current return period
    fprintf('Best parameters for T=%s years: c=%.2f, e=%.2f, f=%.2f\n', T, best_params(1), best_params(2), best_params(3));
    fprintf('Smallest sum of squared errors: %.2f (target: %.2f)\n', best_error, max_errors);
    
    % Check if the error meets the required threshold
    if best_error <= max_errors
        fprintf('The error for T=%s is within the acceptable range!\n', T);
    else
        fprintf('The error for T=%s is above the acceptable range. Try refining the grid.\n', T);
    end
end

%chatgipitou
% Create a table with the calibrated parameter values and errors
param_table = array2table(calibrated_params, 'VariableNames', {'c', 'e', 'f', 'Error'}, ...
                           'RowNames', return_periods);
disp(param_table); % Display the table


% calculer le h estimé
function [h] = estimated_rainfall_depth(D,c,e,f)
    h = (c * D) / (D^e + f);
end 

function error = sum_squared_differences(durations, gumbel_data, c, e, f)
    %initialiser bro
    error = 0; 
    for i = 1:length(durations)
        D = durations(i);
        h_gumbel = gumbel_data(i);
        h_estimated = estimated_rainfall_depth(D, c, e, f);
        error = error + (h_estimated - h_gumbel)^2; 
    end
end
